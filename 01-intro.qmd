---
title: Introduction to Python
---

## Introduction

Python is a general-purpose programming language. It is a higher-level language
than C, C++ and Java in the sense that a Python program does not have to be
compiled before execution.

It was originally conceived back in the 1980s by Guido van Rossum at Centrum
Wiskunde & Informatica (CWI) in the Netherlands. The language is named after a
BBC TV show (Guido’s favorite program) “Monty Python's Flying Circus”.

Python reached version 1.0 in January 1994. Python 2.0 was released on October
16, 2000. Python 3.0, which is backwards-*incompatible* with earlier versions,
was released on 3 December 2008.

Python is a very flexible language; it is simple to learn yet is fast enough to 
be used in production. Over the past ten years, more and more comprehensive data 
science toolkits (e.g. scikit-learn, NTLK, tensorflow, keras) have been written 
in Python and are now the standard frameworks for those models. 

Just like R, Python is an open-source software. It is free to use and extend.

## Installing Python and Jupyter Lab

To install Python, navigate to the official 
[Python download page](https://www.python.org/downloads/) to obtain the 
appropriate installer for your operating system. 

::: {.callout-important}
For our class, please ensure that you are using Python 3.10.12.
:::

The next step is to create a virtual environment for this course. Virtual 
environments are specific to Python. They allow you to retain multiple versions 
of Python, and of packages, on the same computer. Go through the videos on Canvas
relevant to your operating system to create a virtual environment and install 
Jupyter Lab on your machine.

Jupyter notebooks are great for interactive work with Python, but more advanced
users may prefer a full-fledged IDE. If you are an advanced user, and are
comfortable with an IDE of your own choice (e.g. Spyder or VSCode), feel free to
continue using that to run the codes for this course. 

::: {.callout-important}
Even if you are using Anaconda/Spyder/VSCode, you still need to create a virtual
environment.
:::

Jupyter notebooks consist of cells, which can be of three main types: 

* code cells,
* output cells, and 
* markdown cells. 

![Jupyter Lab](figs/jupyter_lab2.png){#fig-jupyter fig-alt="Jupyter Lab" fig-align="center"}

In @fig-jupyter, the red box labelled 1 is a markdown cell. It can be used to
contain descriptions or summary of the code. The cells in the box labelled 2 are
code cells. To run the codes from our notes, you can copy and paste the codes
into a new cell, and then execute them with Ctrl-Enter. 

Try out this Easter egg that comes with any Python installation:

```{python}
import this

```

More information on using Jupyter notebooks can be obtained from 
[this link](https://jupyterlab.readthedocs.io/en/stable/user/interface.html). 

## Basic Data Structures in Python

The main objects in native[^02-python-1] Python that contain data are

[^02-python-1]: i.e., Python without any packages imported.

* **Lists**, which are defined with [ ]. Lists are mutable.
* **Tuples**, which are defined with ( ). Tuples are immutable.
* **Dictionaries**,  which are defined with { }. Dictionaries have keys and 
  items. They are also mutable.
  
Very soon, we shall see that for data analysis, the more common objects we shall
deal with are dataframes (from pandas) and arrays (from numpy). However, the
latter two require add-on packages; the three object classes listed above are
baked into Python.

By the way, this is what mean by (im)mutable:

```{python mutable-1}
x = [1, 3, 5, 7, 8, 9, 10]

# The following is OK, because "x" is a list, and hence mutable
x[3] = 17     
print(x)  
```

```{python mutable-2}
#| eval: false

# The following will return an error, because x_tuple is a tuple, and hence 
# immutable.
x_tuple = (1, 3, 5, 6, 8, 9, 10)
x_tuple[3] = 17 
```

Here is how we create lists, tuples and dictionaries.

```{python create-obj}
x_list = [1, 2, 3]
x_tuple = (1, 2, 3)
x_dict = {'a': 1, 'b': 2, 'c': 3} # access with x_dict['a']
```

## Slice Operator in Python

One important point to take note is that, Python begins indexing of objects
starting with 0. Second, indexing is aided by the slicing operator ':'. It is
used in Python to extract regular sequences from a list, tuple or string easily.

In general, the syntax is `<list-like object>[a:b]`, where `a` and `b` are integers. 
Such a call would return the elements at indices `a`, `a+1` until `b-1`. Take note that 
the end point index is not included.

```{python slice-1}
char_list = ['P', 'y', 't', 'h', 'o', 'n']
char_list[0]           # returns first element
char_list[-1]          # returns last element
len(char_list)         # returns number of elements in list-like object.
char_list[::2]         # from first to last, every 2 apart.
```

This indexing syntax is used in the additional packages we use as well, so it is
good to know about it. @fig-py-slice displays a pictorial representation of how
positive and negative indexes work together.

![Positive and negative indices](figs/python_slice.png){#fig-py-slice fig-alt="Python slice" fig-align="center" width="55%"}

## Loops in Python

It is extremely efficient to execute "for" loops in Python. Many objects in
Python are *iterators*, which means they can be iterated over. Lists, tuples and
dictionaries can all be iterated over very easily.

Before getting down to examples, take note that Python does not use curly braces
to denote code blocks. Instead, these are defined by the number of indentations
in a line.

```{python iter-1}
for i in x[:2]:
  print(f"The current element is {i}.")
```

Notice how we do not need to set up any running index; the object is just iterated 
over directly. The argument to the `print()` function is an f-string. It is the 
recommended way to create string literals that can vary according to arguments.

Here is another example of iteration, this time using dictionaries which have
key-value pairs. In this case, we iterate over the keys.

```{python iter-2}
dict1 = {'holmes': 'male', 'watson': 'male', 'mycroft': 'male', 
         'hudson': 'female', 'moriarty': 'male', 'adler': 'female'}
# dict1['hudson']

for x in dict1.keys():
    print(f"The gender of {x} is {dict1[x]}")
```

## Strings

Text data in Python is handled with `str` objects. A string object is an
**immutable** sequence of characters. Here are some useful string methods and
properties:

*   catenating (joining) strings.
*   finding sub-strings.
*   iterating over strings.
*   converting to lower/upper-case.

A few cells earlier, we saw how we can format a string before sending it to the
`print()` function. Here's another such example. This is useful when we are
debugging loops.

```{python}
#| scrolled: true
for x in range(1, 11):
    print(f"Sq:{x*x:3d} Cu:{x*x*x:4d}.")
```

Here are more examples of working with strings.

```{python}
test_str = "Where in the World is Carmen san Diego?"
```

Remember that a string is immutable, just like a tuple, so this will not work:

`test_str[5] = 'z'`

But like a tuple, we can also iterate over a string.

```{python}
count = 0
for x in test_str:
    if x.isupper():
        count += 1
print(f"There were {count} upper-case characters in the sentence.")
```

```{python}
test_str.lower()
```

To join strings, we can use the '+' operator, the `str.join()` method, or, if
they are part of the same expression, we can just place them next to each other
separated by whitespace.

```{python}
x = "Where shall "
y = "we "
print("Where shall " "we " "go today?")

# also works - the '+' operator is overloaded to work with strings:
# "Where " + "shall" +" we go" + " today?"

# join using another character:
# ':'.join(["Where", "shall", "we", "go", "today?"])
```

To find simple patterns, we may turn to the `find`, `replace`, `startswith` and
`endswith` methods.

```{python}
test_str.find('Carmen')
```

```{python}
test_str.replace('Carmen', 'John')
```

For more complicated search operations over strings, we use a special
mini-language known as regular expressions. These are used in several other
languages such as R and Perl, so it is worth knowing about them if you have
time.

## Functions, Modules and Packages 

Functions provide a way to package code that you can re-use several times. To
define a function in Python, use the `def` keyword.

```{python}
def test_function(x):
    print('You typed', x)
    
test_function('test')
```

A Python module is a file containing Python definitions (of functions and
constants) and statements. Instead of re-typing functions every time, we can
simply load the module. We would then have access to the updated functions.

We access objects within the module using the "dot" notation. There are several
modules that ship with the default Python installation.

Packages are collections of modules.

Here are a couple of ways of importing (and then using) constants from the math
package.

```{python}
import math, os

# compute e^2
math.exp(2)

# print pi
math.pi
```

Alternatively, we could import the constant $\pi$ so that we do not need to use the 
dot notation.

```{python}
from math import pi
pi
```

## Object-Oriented Programming

Python has been developed as both a functional and object-oriented programming
language. Much of the code we will soon use involves creation of an instance,
and then accessing the attributes (data or methods) of that instance.

Consider the following class Circle.

```{python}
class Circle:
    """ A simple class definition 
    
    c0 = Circle()
    c0.radius
    
    """
    def __init__(self, radius = 1.0):
        self.radius = radius
        
    def area(self):
        """ Compute area of circle"""
        return pi*(self.radius**2)
```

Having defined the class, we can *instantiate* it and use the methods it 
contains.

```{python}
c1 = Circle(3.2)
c2 = Circle(4.0)
c2.area()
```

In this simple class, we can also set the value of the attribute of an instance,
although this is not the recommended way.

```{python}
c1.radius = 6
c1.area()
```

## Numpy

```{python}
import numpy as np
import pandas as pd

from itables import show
```

The basic object in this package is the `ndarray` object, which can represent
*n*-dimensional arrays of homogeneous data types. This is the key difference
between NumPy and Pandas objects, which we shall encounter later on in this
chapter. While Pandas objects are also tabular in nature, they allow you to deal
with inhomogenous objects. Specifically, Pandas' `DataFrame`s allow columns to
be of different types.

An `ndarray` object is an *n*-dimensional array (i.e., a
[tensor](https://www.i2tutorials.com/wp-content/uploads/2019/09/Tensor-Datatype-and-Ranks-1i2tutorials.jpg))
of elements, indexed by a tuple of non-negative integers.

The dimensions of the array are referred to as **axes** in NumPy: a 
three-dimensional array will have three axes.

Each array has several attributes. These include:

*   `ndim`: the number of axes/dimensions.
*   `shape`: a tuple describing the length of each dimension.
*   `size`: the total number of elements in the array. This is a product of the 
            integers in the shape attribute.

```{python}
arr = np.array([(1.5, 2, 3), (4, 5, 6)])

# number of axes
arr.ndim
```


```{python}
# the length of each axis
arr.shape
```


```{python}
# number of elements in the array
arr.size
```

### Array Creation

One way to create an array containing regular sequences is to use the
`np.arange()` function. This creates a sequence of integers, with a specified
separation.

```{python}
seq = np.arange(0, 10, 3)
seq
```

The shape of an `ndarray` is given by a tuple. Note that an array of shape (4,)
is different from one with shape (4, 1). The former has only **1 dimension**,
while the latter has **2 dimensions**.

```{python}
# seq.shape
col_vect = seq.reshape(4,1)
col_vect
```

To create an array of regularly spaced **real numbers**, use `np.linspace()`.

```{python}
#| scrolled: true
arr_real = np.linspace(start = 0.2, stop = 3.3, num = 24).reshape(2, 3, 4)  
arr_real
```

Sometimes we need to create a placeholder array with the appropriate dimensions,
and then fill it in later. This is preferrable to growing an array by appending
to it.

```{python}
np.zeros((3, 5)) # there is also an np.ones() function
```

Instead of specifying the dimensions of an array ourselves, we can create arrays
of zeros or ones in the shape of other existing arrays.

```{python}
#| scrolled: true
# Creates an array of zeros, of the same shape as "arr_real".
np.ones_like(arr_real)
```

### Slice Operator in Multiple Dimensions

Multidimensional NumPy arrays can be accessed with comma separated slice
notation. When fewer indices are provided than the number of axes, the missing
indices are considered complete slices for the remaining dimensions.

By the way, when printing, the *last* axis will be printed left-to-right, and
the second last axis will be printed from top-to-bottom. The remaining axes will
be printed with a line in between:

```{python}
arr_real
```

Here are examples based on this array. Try to guess what each will return before
you run it:

```{python}
#| eval: false
arr_real[1,2,3]
arr_real[0, 2, ::-1]
arr_real[1, 0:3:2]
arr_real[:,2,:]
```

Here are examples using Boolean indexing, which means that we use an array of
`True` and `False` entries to determine which elements to return.

```{python}
arr_real > 3
```

```{python}
arr_real[arr_real > 3]
```

### Basic Operations

```{python}
# Setting a seed allows for reproducibility of random number generation
# across sessions.
rng = np.random.default_rng(1361)
```

```{python}
a = rng.uniform(size=(3,5))
b = rng.uniform(size=(3,5))
b
```

```{python}
# Element-wise addition.
a + b 
```

```{python}
# Element-wise multiplication: NOT matrix multiplication.
a * b
```

```{python}
# Matrix multiplication (need to transpose "b" to match get the right dimensions).
# We can also do "a @ b.T".
a.dot(b.T)
```

### Axis-wise Operations

```{python}
arr_real.shape
```

```{python}
arr_real.mean(axis = 0) # mean across the 0th ("first") axis
```

The top-left element comes from the average of `arr_real[0,0,0]` and
`arr_real[1,0,0]`. Similarly, the element to the right of it comes from the average
of `arr_real[0,0,1]` and `arr_real[1,0,1]`:

```{python}
(arr_real[0,0,1] + arr_real[1,0,1]) / 2
```

```{python}
arr_real.mean(axis = 1)
```

Note that `arr_real[0]` is a 2D array, with shape (3, 4). Suppose we wish to
compute the row means. This means we have to apply the operation by the column
axis (axis = 1).

```{python}
# the mean across the second axis of arr_real[0], not of arr_real itself.
arr_real[0].mean(axis = 1) 
```

If we wanted to identify the row with the largest mean, we use `argmax()` on the
resulting array.

```{python}
arr_real[0].mean(axis=1).argmax()
```

Here is a table with some common operations that you can apply on a numpy array. 

| Method      | Description                                 |
|-------------|---------------------------------------------|
| `shape`     | Returns dimensions, e.g. `matrix1.shape`    |
| `T`         | Transposes the array, e.g. `matrix1.T`      |
| `mean`      | Computes col- or row-wise means, e.g. `matrix1.mean(axis=0)` or `matrix1.mean(axis=1)` |
| `sum`       | Computes col- or row-wise means, e.g. `matrix1.sum(axis=0)` or `matrix1.sum(axis=1)` |
| `argmax`    | Return the index corresponding to the max within the specified dimension, e.g. `matrix1.argmax(axis=0)` for the position with the max within each column.  |
| `reshape`   | To change the dimensions, e.g. `array1.reshape((5,1))` converts the array into a 5x1 matrix |

## Pandas

### Series 

A *Series* is a one-dimensional labeled array. The axis labels are referred to
as the **index**. The simplest way to create a Series is to pass a sequence and
an index to `pd.Series()`.

::: {#exm-pd-series-1 style="background-color: #D5D1D164; padding: 20px"}

### Creating Pandas Series

```{python}
year = pd.Series(list(range(2010, 2013) ) * 3)

team = ["Barcelona", "RealMadrid", "Valencia"] * 3
team.sort()
team = pd.Series(team)

wins = pd.Series([30, 28, 32, 29, 32, 26, 21, 17, 19])
draws = pd.Series([6, 7, 4, 5, 4, 7, 8, 10, 8])
losses = pd.Series([2, 3, 2, 4, 2, 5, 9, 11, 11])

#wins.index
#wins.values
```

:::

To access particular values, we can use the slice operator.

```{python}
wins[0:6:2]
```

To convert a Series object to an `ndarray`, we use the following method:

```{python}
wins.to_numpy()
```

If we specify an index, we can use it to access values in the Series.

```{python}
s = pd.Series(rng.uniform(size=5), 
             index=['a', 'b', 'c', 'd', 'e'])
# s
# s.index
# s.values
```

```{python}
s[['a', 'c']] 
```

Be careful when you combine the slice operator with label-based indexing. Unlike vanilla Python, Pandas includes **both** end-points!

```{python}
s['a':'d']
```

### DataFrames

A *DataFrame* is a 2-dimensional labeled data structure with possibly
**different** data types. It is the most commonly used Pandas object. The
*index* of a DataFrame refers to the row labels (axis 0). The *columns* refer to
the column labels (axis 1).

DataFrames can be constructed from Series, dictionaries, lists and 2-d arrays.
For our course, we will typically create a DataFrame directly from a file.

We can create a DataFrame from the earlier series.

```{python}
laliga = pd.DataFrame({'Year': year,
              'Team': team,
              'Wins': wins,
              'Draws': draws,
              'Losses': losses
})
```

To inspect a DataFrame, we can use `info()`, `head()` and `tail()` methods.

```{python}
# laliga.info()
# laliga.head()
```

### Reading in Data

Pandas can read in data stored in multiple formats, including CSV, tab-separated
files, Excel files and HDF5 files.

::: {#exm-pd-happ-1 style="background-color: #D5D1D164; padding: 20px"}

The CSV file read in here contains the happiness scores of 164 countries from
2015 to 2017. Click [here](https://worldhappiness.report/ed/2017/) for a full
report on the dataset. The final score was based on many other factors (such as
GDP per capita, family, freedom etc) which is included in the file as well. We
will simplify things by just reading in the country, final score computed and
year.

In each year, not all of the 164 countries had their scores surveyed and taken.
This results in some countries having missing values (`NaN`) in certain years.

```{python}
happ = pd.read_csv('data/happiness_report.csv', header=0, 
                    na_values='NA')
#show(happ)
happ.info()
```

:::

### Basic Selection

In dataframes, row selection can be done with integers in with the slice
operator. In practice, this is not used, because we typically wish to select a
set of rows based on a condition.

```{python}
#| scrolled: true
happ[10:12]
```

To select columns, you may use a list of column names.

```{python}
happ[['GDP', 'Freedom']] # note the difference with happ['GDP']
# happ.GDP.head()
```

Remember that we are not working with numpy arrays, so this will not work:

```{python}
#| eval: false
happ[0:10, 2:4]
```

### Indexing and Selecting Data

The two main methods of advanced data selection use the `.loc` and `.iloc`
functions. Although we call them functions, they are summoned using the `[ ]`
notation. The `.loc` is primarily label-based. The common allowed inputs to
`.loc` are

*   a single label,
*   a list of labels,
*   a slice object, 
*   a boolean array.

The `.iloc` is primarily an integer-based input. The common allowed inputs to
`.iloc` are

*   a single integer,
*   a list of integers,
*   a slice object, 
*   a boolean array.
  
When selecting from a DataFrame with `.loc` or `.iloc`, we can provide a
comma-separated index, just as with NumPy. It is good to keep this
[reference](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html)
page bookmarked.

*Take note that this next command will only work if the index is made up of integers!*

```{python}
happ.loc[2:5]

# happ.loc[[2,3,4,5]]
```

Notice below how the slice operator is inclusive when we use `.loc`, but not
inclusive when we use `.iloc`.

```{python}
happ.loc[2:10:4, "GDP":"Generosity":2]
```

```{python}
#| scrolled: true
happ.iloc[2:11:4, 3:8:2] # Same as above, but with .iloc
```

### Filtering Data

Suppose we are interested in the very happy countries. Here is how we can filter
the data with a boolean array.

```{python}
happiest = happ[happ['Happiness.Score'] > 6.95]
```

```{python}
happiest.Country.unique()
```

Notice that there isn't a single Asian or African country in the happiest 10% of
countries!

When filtering, we can also combine Boolean indices.

```{python}
# Top 3 happiest countries in 2015
happ[(happ.Year == 2015) & (happ['Happiness.Rank'] <= 3)]
```

### Missing Values

The `.info()` method will yield information on missing values, column by column.
We can see there are 21 rows with missing values.

```{python}
#| scrolled: true
happ.info()
```

*Sometimes*, it is appropriate to drop rows with missing values. This can be done 
with the `.dropna` method. Remember that it returns a new dataframe. The original 
one remains unchanged, unless you include the `inplace=True` argument.

```{python}
new_df = happ.dropna()

# pd.isna(happ)
```

## References

In this chapter, we have introduced the following data science tools:

 * Python programming language
 * Jupyter notebooks for working with Python
 * Computer set-up for data science with Python

Python is very widely used for data science, and especially for the machine
learning aspect of it. For those of you with intentions to take up the GC in
Deep Learning or Data Mining, it will be critical to be familiar with the
language. It will be used again in at least DSA5102.

1. [Regular expression HOWTO](https://docs.python.org/3.10/howto/regex.html) A
   tutorial with examples on regular expressions (for manipulating and searching
   through strings).
2. [Formatting string literals](https://docs.python.org/3/reference/lexical_analysis.html#f-strings): Or just f-strings
3. [Python documentation](https://docs.python.org/3/): This is the official
   Python documentation page. It contains a tutorial, detailed description of the
   usual libraries and HOWTOs for many specific tasks. Most sections contain
   working examples that you can learn from, or modify to suit your task. It is
   good to bookmark it.
4. [Obtaining a github copilot license](https://education.github.com/discount_requests/application?type=student)
   For proof of student status, access EduRec -> Academics -> Academic Records ->
   View Student Status Letter, then take a photo of the pdf. Your application
   status should be shown in the same GitHub page. It will take a few days for the
   copilot access to be granted after your application is approved.
